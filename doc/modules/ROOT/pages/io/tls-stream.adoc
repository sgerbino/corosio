//
// Copyright (c) 2025 Vinnie Falco (vinnie.falco@gmail.com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// Official repository: https://github.com/cppalliance/corosio
//

= TLS Stream

The `tls_stream` class template wraps an underlying stream to provide a
TLS-like interface. This enables writing code that works uniformly with
both encrypted and unencrypted connections.

CAUTION: The current implementation is a placeholder that delegates to
the wrapped stream without actual TLS encryption. A full TLS implementation
is planned for a future release.

NOTE: Code snippets assume the following declarations are in effect:

[source,cpp]
----
#include <boost/corosio.hpp>
namespace corosio = boost::corosio;
----

== Creating a TLS Stream

A TLS stream wraps an existing stream type. Constructor arguments are
forwarded to the underlying stream:

[source,cpp]
----
// Wrap a socket
corosio::tls_stream<corosio::socket> secure_socket(ioc);

// Move an existing socket into the wrapper
corosio::socket raw_socket(ioc);
raw_socket.open();
corosio::tls_stream<corosio::socket> secure(std::move(raw_socket));
----

== Accessing the Underlying Stream

The wrapped stream is accessible as a public member:

[source,cpp]
----
corosio::tls_stream<corosio::socket> secure(ioc);
secure.stream_.open();  // Access underlying socket
----

== Executor Access

The TLS stream forwards executor access to the underlying stream:

[source,cpp]
----
auto ex = secure.get_executor();
----

This returns the same executor as the wrapped stream, ensuring the TLS
stream participates correctly in executor affinity propagation.

== Intended Usage Pattern

The TLS stream adapter enables writing protocol-agnostic code:

[source,cpp]
----
template<class Stream>
capy::task<void> send_request(Stream& s, std::string_view request)
{
    auto [ec, n] = co_await s.write_some(
        boost::buffers::const_buffer(request.data(), request.size()));

    if (ec)
        co_return;

    char response[4096];
    auto [read_ec, bytes] = co_await s.read_some(
        boost::buffers::mutable_buffer(response, sizeof(response)));
}

// Works with plain socket
corosio::socket plain(ioc);
co_await send_request(plain, "GET / HTTP/1.1\r\n\r\n");

// Works with TLS-wrapped socket (once implemented)
corosio::tls_stream<corosio::socket> secure(ioc);
co_await send_request(secure, "GET / HTTP/1.1\r\n\r\n");
----

== Current Limitations

The placeholder implementation has the following restrictions:

* Does not perform TLS handshake
* Does not encrypt or decrypt data
* Simply forwards operations to the wrapped stream

This allows developing and testing application code structure before the
full TLS implementation is available.

== Next Steps

* xref:io/sockets.adoc[Sockets] — The underlying socket operations
* xref:concepts/affine-awaitables.adoc[Affine Awaitables] — How affinity propagates through stream adapters
